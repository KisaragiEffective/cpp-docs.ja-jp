---
title: x64 でのスタックの使用
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: 902e4304ac124be46c6edf0860118dc522b34890
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/16/2020
ms.locfileid: "79422752"
---
# <a name="x64-stack-usage"></a>x64 でのスタックの使用

RSP の現在のアドレスを超えるすべてのメモリは揮発性と見なされます。 OS またはデバッガーは、ユーザーデバッグセッション中にこのメモリを上書きすることも、割り込みハンドラーを上書きすることもできます。 したがって、スタックフレームに対して値の読み取りまたは書き込みを試みる前に、必ず RSP を設定する必要があります。

ここでは、ローカル変数および**alloca**組み込みのスタック領域の割り当てについて説明します。

## <a name="stack-allocation"></a>スタック割り当て

関数のプロローグは、ローカル変数、保存されたレジスタ、スタックパラメーター、およびレジスタパラメーターにスタック領域を割り当てる役割を担います。

パラメーター領域は常にスタックの一番下にあり (`alloca` が使用されている場合でも)、任意の関数呼び出し中に常に戻りアドレスの近くに配置されます。 これには、少なくとも4つのエントリが含まれていますが、呼び出される可能性のある関数で必要なすべてのパラメーターを保持するのに十分な領域が常に必要です。 パラメーター自体がスタックに所属していない場合でも、レジスタパラメーターには常に領域が割り当てられていることに注意してください。呼び出し先は、すべてのパラメーターに対して領域が割り当てられていることが保証されます。 登録引数にはホームアドレスが必要であるため、呼び出された関数が引数リストのアドレス (va_list) または個別の引数を受け取る必要がある場合は、隣接する領域を使用できます。 また、この領域には、サンクの実行時とデバッグオプションとして、レジスタ引数を保存するための便利な場所も用意されています (たとえば、プロローグコードのホームアドレスに格納されている場合、デバッグ時に引数を見つけやすいようにします)。 呼び出された関数のパラメーターの数が4未満の場合でも、これらの4つのスタックの場所は、呼び出された関数によって実質的に所有され、呼び出された関数は、パラメーターレジスタの値を保存する以外に、呼び出し先の関数で使用できます。  したがって、呼び出し元は、関数呼び出し全体のスタックのこの領域に情報を保存することはできません。

空間が動的に割り当てられている場合 (`alloca`)、スタックの固定部分のベースをマークするために、不揮発性レジスタをフレームポインターとして使用する必要があります。そのレジスタは、プロローグで保存して初期化する必要があります。 `alloca` が使用されている場合、同じ呼び出し元からの同じ呼び出し先への呼び出しで、レジスタパラメーターのホームアドレスが異なる場合があることに注意してください。

スタックは常に16バイトでアラインされます。ただし、プロローグ内 (たとえば、リターンアドレスがプッシュされた後) を除き、特定のクラスのフレーム関数の[関数型](#function-types)で指定されている場合を除きます。

次に、関数 A が非リーフ関数 B を呼び出すスタックレイアウトの例を示します。関数 A のプロローグには、スタックの一番下にある B が必要とするすべてのレジスタおよびスタックパラメーターの領域が既に割り当てられています。 呼び出しは、戻りアドレスをプッシュし、B のプロローグはローカル変数、不揮発性レジスタ、および関数の呼び出しに必要な領域を割り当てます。 B が `alloca`を使用する場合は、ローカル変数/不揮発性レジスタの保存領域とパラメータースタック領域の間に領域が割り当てられます。

![AMD 変換の例](../build/media/vcamd_conv_ex_5.png "AMD 変換例")

関数 B が別の関数を呼び出すと、戻りアドレスは RCX のホームアドレスのすぐ下にプッシュされます。

## <a name="dynamic-parameter-stack-area-construction"></a>動的パラメータースタック領域の構築

フレームポインターが使用されている場合は、パラメータースタック領域を動的に作成するためのオプションが存在します。 これは現在、x64 コンパイラでは実行されていません。

## <a name="function-types"></a>関数の種類

基本的には、次の2種類の関数があります。 スタックフレームを必要とする関数は、*フレーム関数*と呼ばれます。 スタックフレームを必要としない関数は、*リーフ関数*と呼ばれます。

フレーム関数は、スタック領域を割り当てたり、他の関数を呼び出したり、不揮発性レジスタを保存したり、例外処理を使用したりする関数です。 また、関数テーブルのエントリも必要です。 フレーム関数にはプロローグとエピローグが必要です。 フレーム関数は、スタック領域を動的に割り当てたり、フレームポインターを使用したりすることができます。 フレーム関数は、この呼び出し元の完全な機能を自由に保持します。

フレーム関数が別の関数を呼び出さない場合、スタックを配置する必要はありません (セクション[スタック割り当て](#stack-allocation)で参照されます)。

リーフ関数は、関数テーブルエントリを必要としないものです。 RSP を含む任意の不揮発性レジスタを変更することはできません。これは、関数を呼び出したりスタック領域を割り当てたりすることができないことを意味します。 実行中にスタックを整列したままにすることができます。

## <a name="malloc-alignment"></a>malloc アラインメント

[malloc](../c-runtime-library/reference/malloc.md)は、基本的なアラインメントを持つオブジェクトを格納するために適切に配置され、割り当てられたメモリの量に適合する可能性があるメモリを返すことが保証されています。 *基本的*なアラインメントは、アラインメントを指定せずに実装でサポートされている最大のアラインメントと同じかそれ以下のアラインメントです。 (Visual C++ の基本的なアラインメントは、`double` つまり 8 バイトに対して必要なアラインメントです。 64ビットプラットフォームを対象とするコードでは、16バイトです)。たとえば、4バイトの割り当ては、4バイトまたはそれより小さいオブジェクトをサポートする境界に沿って配置されます。

ビジュアルC++では、拡張された*アラインメント*を持つ型を許可します。これは、*境界を越え*た型とも呼ばれます。 たとえば、SSE 型[__m128](../cpp/m128.md)と `__m256`、および `n` が8より大きい `__declspec(align( n ))` を使用して宣言されている型の場合、アラインメントは拡張されます。 オブジェクトで拡張アラインメントが必要な場合、そのオブジェクトに適した境界上でのメモリのアラインメントは、`malloc` によって保証されません。 過剰に固定された型にメモリを割り当てるには、 [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md)と関連する関数を使用します。

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md)は、16バイトでアラインする必要があり、さらにフレームポインターを使用するために必要です。

割り当てられているスタックには、後の「[スタックの割り当て](#stack-allocation)」で説明されているように、後で呼び出される関数のパラメーターのためのスペースを含める必要があります。

## <a name="see-also"></a>参照

[x64 ソフトウェア規約](../build/x64-software-conventions.md)<br/>
[align](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
